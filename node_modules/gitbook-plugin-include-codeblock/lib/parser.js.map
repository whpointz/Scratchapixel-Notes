{"version":3,"sources":["../src/parser.js"],"names":["splitLabelToCommands","strip","containIncludeCommand","parseValue","parseVariablesFromLabel","generateEmbedCode","getContent","embedCode","parse","path","require","Handlebars","logger","markdownLinkFormatRegExp","keyEx","kvsepEx","spacesEx","quoteEx","valEx","argEx","expressionEx","expressionRegExp","RegExp","markerRegExp","codeCounter","count","label","result","split","map","command","trim","filter","length","s","undefined","indents","match","m","smallestIndent","sort","a","b","replace","commands","reg","some","test","value","type","key","unescapedvalue","substring","error","indexOf","kvMap","kv","Object","assign","exec","hasOwnProperty","parsedValue","freeze","fileName","originalPath","content","backtick","tContent","contextMap","handlebars","compile","filePath","code","basename","kvmparsed","kvm","unindent","start","end","marker","baseDir","options","results","res","all","absolutePath","resolve","replacedContent","push","target","replaced"],"mappings":"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","file":"parser.js","sourcesContent":["// LICENSE : MIT\n\"use strict\";\nconst path = require(\"path\");\nconst Handlebars = require(\"handlebars\");\nconst logger = require(\"winston-color\");\nimport { defaultKeyValueMap, initOptions, checkMapTypes } from \"./options.js\";\nimport { unescapeString } from \"./unescape-string.js\";\nimport { getLang } from \"./language-detection\";\nimport { getMarker, hasMarker, markerSliceCode, removeMarkers } from \"./marker\";\nimport { sliceCode, hasSliceRange, getSliceRange } from \"./slicer\";\nimport { hasTitle } from \"./title\";\nimport { getTemplateContent, readFileFromPath } from \"./template\";\nimport { codeBlockBacktick } from \"./backtick-maker\";\n\nconst markdownLinkFormatRegExp = /\\[(?=((?:[^\\]]|\\\\.)*))\\1\\]\\((?=((?:[^\\)]|\\\\.)*))\\2\\)/gm;\n\nconst keyEx = \"\\\\w+\";\nconst kvsepEx = \"[:=]\";\nconst spacesEx = \"\\\\s*\";\nconst quoteEx = \"[\\\"']\";\nconst valEx = \"(?:[^'\\\"\\\\\\\\]|\\\\\\\\.)*\";\nconst argEx = `${quoteEx}${valEx}${quoteEx}|true|false`;\nconst expressionEx = `(${keyEx})${kvsepEx}${spacesEx}(${argEx})`;\nconst expressionRegExp = new RegExp(expressionEx, \"g\");\n\nconst markerRegExp = /^\\s*(([-\\w\\s]*,?)*)$/;\n\n/**\n * A counter to count how many code are imported.\n */\nvar codeCounter = (function() {\n    var count = 0;\n    return function() {\n        return count++;\n    }; // Return and increment\n})();\n\n/**\n * split label to commands\n * @param {string} label\n * @returns {Array}\n */\nexport function splitLabelToCommands(label = \"\") {\n    const result = label.split(/(:|[,\\s])/);\n    if (!result) {\n        return [];\n    }\n    // remove null command\n    return result\n        .map(command => {\n            return command.trim();\n        })\n        .filter(command => {\n            return command.length > 0;\n        });\n}\n\n/**\n * Unindent code\n * @param {string} s\n * @return {string}\n */\nexport function strip(s) {\n    // inspired from https://github.com/rails/rails/blob/master/activesupport/lib/active_support/core_ext/string/strip.rb\n    if (s === undefined || s === \"\") {\n        return s;\n    }\n    const indents = s\n        .split(/\\n/)\n        .map(s => s.match(/^[ \\t]*(?=\\S)/))\n        .filter(m => m)\n        .map(m => m[0]);\n    const smallestIndent = indents.sort((a, b) => a.length - b.length)[0];\n    return s.replace(new RegExp(`^${smallestIndent}`, \"gm\"), \"\");\n}\n\n/**\n * if contain \"include\" or \"import\" command, then return true\n * @param {Array} commands\n * @returns {boolean}\n */\nexport function containIncludeCommand(commands = []) {\n    const reg = /^(include|import)$/;\n    return commands.some(command => {\n        return reg.test(command.trim());\n    });\n}\n\n/**\n * Parse the given value to the given type. Returns the value if valid, otherwise returns undefined.\n * @param {string} value\n * @param {string} type \"string\", \"boolean\"\n * @param {string} key\n * @return {boolean|string|undefined}\n */\nexport function parseValue(value, type, key) {\n    if (type === \"string\") {\n        const unescapedvalue = unescapeString(value.substring(1, value.length - 1));\n        if (key === \"marker\" && !markerRegExp.test(unescapedvalue)) {\n            logger.error(\n                \"include-codeblock: parseVariablesFromLabel: invalid value \" +\n                    `\\`${unescapedvalue}\\` in key \\`marker\\``\n            );\n            return undefined;\n        }\n        return unescapedvalue;\n    }\n\n    if (type === \"boolean\") {\n        if ([\"true\", '\"true\"', \"'true'\"].indexOf(value) >= 0) {\n            return true;\n        }\n\n        if ([\"false\", '\"false\"', \"'false'\"].indexOf(value) >= 0) {\n            return false;\n        }\n\n        logger.error(\n            \"include-codeblock: parseVariablesFromLabel: invalid value \" +\n                `\\`${value}\\` in key \\`${key}\\`. Expect true or false.`\n        );\n        return undefined;\n    }\n\n    logger.error(\n        `include-codeblock: parseVariablesFromLabel: unknown key type \\`${type}\\` (see options.js)`\n    );\n    return undefined;\n}\n\n/** Parse the command label and return a new key-value object\n * @example\n *      [import,title:\"<thetitle>\",label:\"<thelabel>\"](path/to/file.ext)\n * @param {object} kvMap\n * @param {string} label\n * @return {object}\n */\nexport function parseVariablesFromLabel(kvMap, label) {\n    const kv = Object.assign({}, kvMap);\n\n    let match = \"\";\n    while ((match = expressionRegExp.exec(label))) {\n        let key = match[1];\n        if (key === \"include\" || key === \"import\") {\n            key = \"marker\";\n        }\n        const value = match[2];\n\n        if (!kv.hasOwnProperty(key)) {\n            logger.error(\n                \"include-codeblock: parseVariablesFromLabel: unknown key \" +\n                    `\\`${key}\\` (see options.js)`\n            );\n            return;\n        }\n\n        const parsedValue = parseValue(value, typeof defaultKeyValueMap[key], key);\n        if (parsedValue !== undefined) {\n            kv[key] = parsedValue;\n        }\n    }\n\n    return Object.freeze(kv);\n}\n\n/**\n * generate code from options\n * @param {object} kvMap\n * @param {string} fileName\n * @param {string} originalPath\n * @param {string} content\n * @param {string} backtick\n * @return {string}\n */\nexport function generateEmbedCode(kvMap, { fileName, originalPath, content, backtick }) {\n    const tContent = getTemplateContent(kvMap);\n    const kv = Object.assign({}, kvMap);\n    const count = hasTitle(kv) ? codeCounter() : -1;\n    checkMapTypes(kvMap, \"generatedEmbedCode\");\n    const contextMap = Object.assign({}, kvMap, {\n        content: content,\n        count: count,\n        fileName: fileName,\n        originalPath: originalPath,\n        backtick\n    });\n    // compile template\n    const handlebars = Handlebars.compile(tContent);\n    // compile with data.\n    return handlebars(contextMap);\n}\n\n/**\n * return content from file or url.\n * @param {string} filePath it should be absolute path\n * @return {string}\n */\nexport function getContent(filePath) {\n    return readFileFromPath(filePath);\n}\n\n/**\n * generate code with options\n * @param {object} kvMap\n * @param {string} filePath\n * @param {string} originalPath\n * @param {string} label\n * @return {string}\n */\nexport function embedCode(kvMap, { filePath, originalPath, label }) {\n    const code = getContent(filePath);\n    const fileName = path.basename(filePath);\n    const kvmparsed = parseVariablesFromLabel(kvMap, label);\n    const kvm = getLang(kvmparsed, originalPath);\n    const unindent = kvm.unindent;\n\n    let content = code;\n    // Slice content via line numbers.\n    if (hasSliceRange(label)) {\n        const [start, end] = getSliceRange(label);\n        content = sliceCode(code, start, end, unindent);\n    } else if (hasMarker(kvm)) {\n        // Slice content via markers.\n        const marker = getMarker(kvm);\n        content = removeMarkers(markerSliceCode(code, marker));\n    }\n    if (unindent === true) {\n        content = strip(content);\n    }\n\n    const backtick = codeBlockBacktick(content);\n    return generateEmbedCode(kvm, { fileName, originalPath, content, backtick });\n}\n\n/**\n * Parse command using options from pluginConfig.\n * @param {string} content\n * @param {string} baseDir\n * @param {{template?: string}} options\n * @return {Array}\n */\nexport function parse(content, baseDir, options = {}) {\n    const results = [];\n    const kvMap = initOptions(options);\n    let res = true;\n    while ((res = markdownLinkFormatRegExp.exec(content))) {\n        const [all, label, originalPath] = res;\n        const commands = splitLabelToCommands(label);\n        if (containIncludeCommand(commands)) {\n            const absolutePath = path.resolve(baseDir, originalPath);\n            const replacedContent = embedCode(kvMap, {\n                filePath: absolutePath,\n                originalPath: originalPath,\n                label\n            });\n            results.push({\n                target: all,\n                replaced: replacedContent\n            });\n        }\n    }\n    return results;\n}\n"]}