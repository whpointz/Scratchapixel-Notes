{"./":{"url":"./","title":"Introduction","keywords":"","body":"Scratchapixel-Notes Learn Computer Graphics From Scratch! Volume 0 Mathematics and Physics for Computer Graphics 0.0 Geometry 0.1_Mathematical Foundations of Monte Carlo Methods Copyright whpointz 2017 all right reserved，powered by GitbookThe revision time: 2017-11-07 15:59:28 "},"volume-0-mathematics-and-physics-for-computer-graphics.html":{"url":"volume-0-mathematics-and-physics-for-computer-graphics.html","title":"Volume 0 Mathematics and Physics for Computer Graphics","keywords":"","body":"几何学 几何是数学的一个分支，涉及了形状，尺寸，图像相对位置以及空间特征等问题。 关键词： 矢量 点 矩阵 正态 变换 笛卡尔坐标系 笛卡尔坐标 球坐标 坐标系 蒙特卡罗方法的数学基础 蒙特·卡罗方法（Monte Carlo method），也称统计模拟方法，是以概率统计理论为指导的一类非常重要的数值计算方法。 关键词： 蒙特卡罗方法 蒙特卡洛积分 随机变量 概率统计 期望值 方差 标准差 概率分布 概率密度函数 累积分布函数 逆变换抽样方法 估计量 Copyright whpointz 2017 all right reserved，powered by GitbookThe revision time: 2017-11-07 17:38:46 "},"Volume_0_Mathematics_and_Physics_for_Computer_Graphics/0.0_Geometry.html":{"url":"Volume_0_Mathematics_and_Physics_for_Computer_Graphics/0.0_Geometry.html","title":"0.0 Geometry","keywords":"","body":" 点、向量和法向量 齐次坐标系 关于点和向量的数学操作 矩阵 矩阵的原理：第1部分 矩阵的原理：第2部分 点和向量的移动 以行为主还是以列为主？ 矩阵操作 球坐标系和三角函数 正规矩阵 点、向量和法向量 一般情况下，点是三维空间中的一个位置，矢量是三维空间中的方向。三维的点和向量是类似的，都使用以下元组符号表示： V=(x,y,z)V = (x,y,z)V=(x,y,z) 齐次点(homogeneous points)，有时候为了数学上的方便，有必要添加第四个元素www，这就是齐次点。PH=(x,y,z,w)P_{H} = (x,y,z,w)P​H​​=(x,y,z,w) 法向量(Normals) 是描述几何对象表面上的一个点的方向。 在技术上，在点PPP处的法向量可以被看作是与该表面相切的平面的法向量。 齐次坐标系 笛卡尔坐标系(Cartesian coordinate system)，是直角坐标系和斜角坐标系的统称。 相交于原点的两条数轴，构成了平面放射坐标系。如果两条数轴上的度量单位相等，则称此放射性坐标系为笛卡尔坐标系。 如果两条数轴相互垂直，则为笛卡尔直角坐标系，否则是笛卡尔斜角坐标系。 左手坐标系和右手坐标系 通常情况下不管是左手还是右手，中指都指向Z轴。 一般情况下，我们使用的都是右手坐标系：即X轴指向纸的右面，Y轴指向纸的上面，Z轴指向纸的外面，对应右手坐标系就是拇指是X，食指是Y，中指是Z。 关于点和向量的数学操作 向量的长度： ∣∣V∣∣=V.xV.x+V.yV.y+V.z∗V.z||V|| = \\sqrt{V.x_V.x + V.y_V.y + V.z*V.z}∣∣V∣∣=√​V.x​V​​.x+V.y​V​​.y+V.z∗V.z​​​ 归一化向量： V^=V∣∣V∣∣\\hat{V} = \\frac {V} {||V||}​V​^​​=​∣∣V∣∣​​V​​ 点积 数量积：一个向量在另一个向量上的投影，返回一个实数 A⋅B=A.xB.x+A.yB.y+A.zB.z=∣∣A∣∣∗∣∣B∣∣∗cos(θ)A {\\cdot} B = A.x B.x + A.y B.y + A.zB.z = ||A|| * ||B|| * cos(\\theta)A⋅B=A.xB.x+A.yB.y+A.zB.z=∣∣A∣∣∗∣∣B∣∣∗cos(θ) 当两个向量被归一化的时候，使用点积的反余弦值可以得到两个向量之间的角度 θ\\thetaθ。θ=cos−1(A⋅B∣∣A∣∣∗∣∣B∣∣)\\theta = cos^{-1}(\\frac{A \\cdot B}{||A|| * ||B||})θ=cos​−1​​(​∣∣A∣∣∗∣∣B∣∣​​A⋅B​​) 点积运算复合交换律、分配律和组合律。 叉乘 矢量积：叉乘为返回一个垂直于向量AAA和向量BBB的向量CCC，C=A×BC = A \\times BC=A×B 得到的结果向量的模 ∣C∣=∣A∣∗∣B∣∗sin(θ)|C| = |A| * |B| * sin(\\theta)∣C∣=∣A∣∗∣B∣∗sin(θ) 将CCC展开为 CX=AYBZ−AZBYC_{X} = A_{Y} B_{Z} - A_{Z} B_{Y}C​X​​=A​Y​​B​Z​​−A​Z​​B​Y​​ CY=AZBX−AXBZC_{Y} = A_{Z} B_{X} - A_{X} B_{Z}C​Y​​=A​Z​​B​X​​−A​X​​B​Z​​ CZ=AXBY−AYBXC_{Z} = A_{X} B_{Y} - A_{Y} B_{X}C​Z​​=A​X​​B​Y​​−A​Y​​B​X​​ 叉乘没有交换律 A×B=CA\\times B = CA×B=C B×A=−CB\\times A = -CB×A=−C (1,0,0)×(0,1,0)=(0,0,1)(1,0,0)\\times (0,1,0) = (0,0,1)(1,0,0)×(0,1,0)=(0,0,1) (0,1,0)×(1,0,0)=(0,0,−1)(0,1,0)\\times (1,0,0) = (0,0,-1)(0,1,0)×(1,0,0)=(0,0,−1) 叉乘运算复合右手定则：向量CCC的方向为使用右手坐标系时向量AAA握拳到向量BBB时（握拳转动的角度不超过180°），大拇指所指的方向。 矩阵 一般我们使用m∗nm * nm∗n来描述一个矩阵的行和列（rows and columns），使用符号 MijM {i j}Mij 描述矩阵M中的第iii行第jjj列的元素。 在CG中我们只要使用的是方阵，一般是333 333或者444 444。 矩阵相乘的操作是点和向量矩阵变换过程的核心。矩阵乘法得到的结果是另一个矩阵。 矩阵相乘的时候，第一个矩阵的列必须等于第二个矩阵的行:[M×P]∗[P×N]=[M×N][M\\times P] * [P\\times N] = [M\\times N][M×P]∗[P×N]=[M×N] 矩阵乘法没有交换律。 但是矩阵乘法有结合律。 矩阵的原理：第1部分 教程中所讲的矩阵乘法都是右乘：即将矩阵写在乘号的右边，此时将向量看成是一行。\\ 但在一些OpenGL使用的3D开源库（比如glm）中是左乘：即将矩阵写在乘号的左边，此时将向量看成是一列。 点和向量是三个数字的序列，因此可以写成是1×31\\times 31×3的矩阵。 P=[xyz]P = \r \\left[\r \\begin{array}{cc} \r x y z\r \\end{array} \r \\right]P=[​xyz​​] 一个点乘于一个矩阵结果是一个点。 [xyz]∗[C00C01C02C10C11C12C20C21C22]\\left[ x y z \\right] * \r \\left[ \r \\begin{array}{cc} \r C_{00} & C_{01} & C_{02} \\\\\r C_{10} & C_{11} & C_{12} \\\\\r C_{20} & C_{21} & C_{22}\r \\end{array} \r \\right][xyz]∗​⎣​⎡​​​C​00​​​C​10​​​C​20​​​​​C​01​​​C​11​​​C​21​​​​​C​02​​​C​12​​​C​22​​​​​⎦​⎤​​ 单位矩阵是一个方阵，除了对角线上的系数为1，别的系数都为0。 缩放矩阵Scale是将点的坐标乘于一些实数，这样点的坐标就会产生缩放。 [Sx000Sy000Sz]\\left[ \r \\begin{array}{cc} \r S{x} & 0 & 0 \\\\\r 0 & S{y} & 0 \\\\ \r 0 & 0 & S_{z}\r \\end{array} \r \\right]​⎣​⎡​​​Sx​0​0​​​0​Sy​0​​​0​0​S​z​​​​​⎦​⎤​​ 旋转矩阵Rotate\\将一个点或者是一个向量绕着坐标系的一个轴来旋转。 Rx(θ)=[1000cos(θ)sin(θ)0−sin(θ)cos(θ)]R_{x}(\\theta) = \r \\left[ \r \\begin{array}{cc} \r 1 & 0 & 0 \\\\ \r 0 & cos(\\theta) & sin(\\theta) \\\\ \r 0 & -sin(\\theta) & cos(\\theta)\r \\end{array} \r \\right]R​x​​(θ)=​⎣​⎡​​​1​0​0​​​0​cos(θ)​−sin(θ)​​​0​sin(θ)​cos(θ)​​​⎦​⎤​​ Ry(θ)=[cos(θ0−sin(θ)010sin(θ)0cos(θ)]R_{y}(\\theta) = \r \\left[ \r \\begin{array}{cc} \r cos(\\theta & 0 & -sin(\\theta) \\\\ \r 0 & 1 & 0 \\\\ \r sin(\\theta) & 0 & cos(\\theta)\r \\end{array} \r \\right]R​y​​(θ)=​⎣​⎡​​​cos(θ​0​sin(θ)​​​0​1​0​​​−sin(θ)​0​cos(θ)​​​⎦​⎤​​ Rz(θ)=[cos(θ)sin(θ)0−sin(θ)cos(θ)0001]R {z}(\\theta) = \r \\left[ \r \\begin{array}{cc} \r cos(\\theta) & sin(\\theta) & 0 \\\\ \r -sin(\\theta) & cos(\\theta)& 0 \\\\ \r 0 & 0 &1\r \\end{array} \r \\right]Rz(θ)=​⎣​⎡​​​cos(θ)​−sin(θ)​0​​​sin(θ)​cos(θ)​0​​​0​0​1​​​⎦​⎤​​ 平移矩阵Translate 必须要使用4×44\\times 44×4的变换矩阵才能解决这个问题。 组合矩阵 可以将RxR_{x}R​x​​ 和 RyR_{y}R​y​​ 组合成一个新的旋转矩阵。但是要注意组合的顺序，Rxy=Rx∗RyR_{xy} = R_{x} * R {y}R​xy​​=R​x​​∗Ry，这个时候就是先旋转X轴然后旋转Y轴，一起组合成一个新的旋转。 比如想先缩放一个点，然后旋转一个点，矩阵分别为SSS和RRR。 当然在左乘和右乘里面的S和R是不一样的，互为转置矩阵。 左乘是 P^=[R∗(S∗P)]\\hat{P} = [R * (S * P)]​P​^​​=[R∗(S∗P)] 右乘是 P^=[(P∗S)∗R]\\hat{P} = [(P * S) * R]​P​^​​=[(P∗S)∗R] 要记住矩阵相乘有结合律。 矩阵的原理：第2部分 矩阵和坐标系的关系矩阵的每一行表示坐标系的轴（或者是基数）。 比如旋转矩阵是这样的：Rz(θ)=[cos(θ)sin(θ)0−sin(θ)cos(θ)0001]R {z}(\\theta) = \r \\left[ \r \\begin{array}{cc} \r cos(\\theta) & sin(\\theta) & 0 \\\\\r -sin(\\theta) & cos(\\theta)& 0 \\\\\r 0 & 0 &1 \r \\end{array} \r \\right]Rz(θ)=​⎣​⎡​​​cos(θ)​−sin(θ)​0​​​sin(θ)​cos(θ)​0​​​0​0​1​​​⎦​⎤​​ 当我们使用旋转矩阵将点P=[1,0,0]P=[1,0,0]P=[1,0,0] 绕z轴旋转 θ\\thetaθ角度的时候，P^=[cos(θ),sin(θ),0]\\hat{P} = [cos(\\theta),sin(\\theta),0]​P​^​​=[cos(θ),sin(θ),0] 当我们使用旋转矩阵将点P=[0,1,0]P=[0,1,0]P=[0,1,0] 绕z轴旋转 θ\\thetaθ角度的时候，P^=[−sin(θ),cos(θ),0]\\hat{P} = [-sin(\\theta),cos(\\theta),0]​P​^​​=[−sin(θ),cos(θ),0] 则当我们使用旋转矩阵将点P=[1,1,0]P=[1,1,0]P=[1,1,0] 绕z轴旋转 θ\\thetaθ角度的时候，P^=[cos(θ)−sin(θ),sin(θ)+cos(θ),0]\\hat{P} = [cos(\\theta)-sin(\\theta),sin(\\theta)+cos(\\theta),0]​P​^​​=[cos(θ)−sin(θ),sin(θ)+cos(θ),0] 正交矩阵 正交矩阵使用Q来表示。正交矩阵的转置矩阵等于其逆矩阵。 QT=Q−1Q^{T} = Q^{-1}Q​T​​=Q​−1​​ QQT=IQQ^{T}=IQQ​T​​=I 正交矩阵的n个行或者列向量是n维空间的一组标准正交基。 点和向量的移动 点的移动，之前点的旋转以及点的缩放都可以直接使用3∗33*33∗3的矩阵来对1∗31*31∗3的点进行操作，但是当要对点进行移动操作时，必须使用4∗44*44∗4的矩阵来对1∗41*41∗4的点进行操作。 1∗41*41∗4的点记作[xyzw][x y z w][xyzw]，一般情况下w为1。 乘于4∗44*44∗4的矩阵之后， P^.x=P.x∗M00+P.y∗M10+P.z∗M20+M30\\hat{P}.x = P.x*M_{00} + P.y*M_{10} + P.z*M_{20} + M_{30}​P​^​​.x=P.x∗M​00​​+P.y∗M​10​​+P.z∗M​20​​+M​30​​ P^.y=P.x∗M01+P.y∗M11+P.z∗M21+M31\\hat{P}.y = P.x*M_{01} + P.y*M_{11} + P.z*M_{21} + M_{31}​P​^​​.y=P.x∗M​01​​+P.y∗M​11​​+P.z∗M​21​​+M​31​​ P^.z=P.x∗M02+P.y∗M12+P.z∗M22+M32\\hat{P}.z = P.x*M_{02} + P.y*M_{12} + P.z*M_{22} + M_{32}​P​^​​.z=P.x∗M​02​​+P.y∗M​12​​+P.z∗M​22​​+M​32​​ P^.w=P.x∗M03+P.y∗M13+P.z∗M23+M33\\hat{P}.w = P.x*M_{03} + P.y*M_{13} + P.z*M_{23} + M_{33}​P​^​​.w=P.x∗M​03​​+P.y∗M​13​​+P.z∗M​23​​+M​33​​ 齐次点 点的w的存在就是为了归一化，当使用透视变换矩阵的时候，w会变成非1，这个时候需要对点P进行归一化，这样可以得到一个在笛卡尔坐标系中的点。 以行为主还是以列为主？ 在之前通常把向量写成一行三列的形式： P=[xyz]P =\r \\left[ \r \\begin{array}{cc} \r x & y & z\r \\end{array} \r \\right]P=[​x​​​y​​​z​​] 也可以将向量写成三行一列的形式： P=[xyz]P =\r \\left[ \r \\begin{array}{cc} \r x \\\\\r y \\\\\r z\r \\end{array} \r \\right]P=​⎣​⎡​​​x​y​z​​​⎦​⎤​​ 以行为主或者是以列为主模式只是一个习惯。 当是一行三列的时候： [xyz]∗[C00C01C02C10C11C12C20C21C22]=[x′y′z′]\r \\left[ \r \\begin{array}{cc} \r x & y & z\r \\end{array} \r \\right] * \\left[ \r \\begin{array}{cc} \r C_{00} & C_{01} & C_{02} \\\\\r C_{10} & C_{11} & C_{12} \\\\\r C_{20} & C_{21} & C_{22}\r \\end{array} \r \\right] = \\left[ \r \\begin{array}{cc} \r x' & y' & z'\r \\end{array} \r \\right] [​x​​​y​​​z​​]∗​⎣​⎡​​​C​00​​​C​10​​​C​20​​​​​C​01​​​C​11​​​C​21​​​​​C​02​​​C​12​​​C​22​​​​​⎦​⎤​​=[​x​′​​​​​y​′​​​​​z​′​​​​] 当是三行一列的时候： [C00C01C02C10C11C12C20C21C22]∗[xyz]=[x′y′z′]\r \\left[ \r \\begin{array}{cc} \r C_{00} & C_{01} & C_{02} \\\\\r C_{10} & C_{11} & C_{12} \\\\\r C_{20} & C_{21} & C_{22}\r \\end{array} \r \\right] * \\left[ \r \\begin{array}{cc} \r x \\\\ y \\\\ z\r \\end{array} \r \\right] = \\left[ \r \\begin{array}{cc} \r x' \\\\ y' \\\\ z'\r \\end{array} \r \\right] ​⎣​⎡​​​C​00​​​C​10​​​C​20​​​​​C​01​​​C​11​​​C​21​​​​​C​02​​​C​12​​​C​22​​​​​⎦​⎤​​∗​⎣​⎡​​​x​y​z​​​⎦​⎤​​=​⎣​⎡​​​x​′​​​y​′​​​z​′​​​​​⎦​⎤​​ 若将左乘变成右乘，那么要对前面的变换矩阵CCC做出转置变成CTC^{T}C​T​​。 变换的结合顺序 若想对点P先使用变换矩阵T，然后绕Z轴旋转矩阵Rz，然后绕Y轴旋转矩阵Ry，得到点P'。 使用一行三列的时候（被称为左乘或者前乘）： P′=P∗T∗Rz∗RyP' = P * T * Rz * RyP​′​​=P∗T∗Rz∗Ry 使用三行一列的时候（被称为右乘或者后乘）： P′=Ry∗Rz∗T∗PP' = Ry * Rz * T * PP​′​​=Ry∗Rz∗T∗P 因为矩阵的乘法符合结合律。 行主矩阵约定使得矩阵更易读，这就是我们将其用于Scratchapixel（以及Maya，DirectX）的原因。然而，一些3D API（如OpenGL）使用列主要约定。 矩阵操作 矩阵的转置MTM^{T}M​T​​ 矩阵的转置MTM^{T}M​T​​与矩阵MMM与主对角线对称，即MijT=MjiM^{T}_{ij} = M_{ji}M​ij​T​​=M​ji​​。 逆矩阵M−1M^{-1}M​−1​​ M∗M−1=IM*M^{-1} = IM∗M​−1​​=I 逆矩阵在3D变换中是一个很重要的概念，可以使用矩阵来转换点或者是向量，但是将变换之后的点或者向量恢复到变换之前的位置就需要逆矩阵的转换。 正交矩阵： QT=Q−1Q^{T} = Q^{-1}Q​T​​=Q​−1​​ 球坐标系和三角函数 在线性代数中可以使用球面坐标来表示向量。 三角函数 角度值 θradians\\theta_{radians}θ​radians​​ 弧度制 θdegrees\\theta_{degrees}θ​degrees​​ 转换关系 θradians=/pi/180∗θdegrees\\theta_{radians} = /pi / 180 * \\theta_{degrees} θ​radians​​=/pi/180∗θ​degrees​​ sin(θ)=Pxsin(\\theta) = P_{x}sin(θ)=P​x​​ cos(θ)=Pycos(\\theta) = P_{y}cos(θ)=P​y​​ tan(θ)=Py/Pxtan(\\theta) = P_{y}/P_{x}tan(θ)=P​y​​/P​x​​ asin(Px)=θasin(P_{x}) = \\thetaasin(P​x​​)=θ acos(Py)=θacos(P_{y}) = \\thetaacos(P​y​​)=θ atan2(Py,Px)=θatan2(P_{y},P_{x}) = \\thetaatan2(P​y​​,P​x​​)=θ 用球面坐标表示向量 用仰角和方位角两个角来表示向量。 (θ,ϕ)(\\theta,\\phi)(θ,ϕ) θ∈[0:π]\\theta \\in [0:\\pi]θ∈[0:π] ϕ∈[0:2π]\\phi \\in [0:2\\pi]ϕ∈[0:2π] 如下图所示： Z轴是向上的轴 在数学和物理中表示向量的惯例是将向上的轴命名为Z轴。和上图一样，使用的是左手坐标系。 已知点P的坐标为： P=[x,y,z,w]P = [x,y,z,w]P=[x,y,z,w] 坐标系的转换是一件相当麻烦的事情，有的时候需要一个转换矩阵： T=[1000001001000001]T = \r \\left[ \r \\begin{array}{cc} \r 1 & 0 & 0 & 0 \\\\\r 0 & 0 & 1 & 0 \\\\\r 0 & 1 & 0 & 0 \\\\\r 0 & 0 & 0 & 1 \r \\end{array} \r \\right]\r T=​⎣​⎢​⎢​⎡​​​1​0​0​0​​​0​0​1​0​​​0​1​0​0​​​0​0​0​1​​​⎦​⎥​⎥​⎤​​ 那么 P∗T=[x,z,y,w]P*T = [x,z,y,w]P∗T=[x,z,y,w] 这就是坐标系的转换。 将笛卡尔坐标转换为球坐标 [Vx,Vy,Vz]−>(θ,ϕ)[Vx,Vy,Vz]->(\\theta,\\phi)[Vx,Vy,Vz]−>(θ,ϕ) θ=acos(Vz);\\theta = acos(Vz); θ=acos(Vz); ϕ=atan2(Vy,Vx);\\phi = atan2(Vy, Vx); ϕ=atan2(Vy,Vx); 球坐标到笛卡尔坐标 (θ,ϕ)−>[Vx,Vy,Vz](\\theta,\\phi)->[Vx,Vy,Vz](θ,ϕ)−>[Vx,Vy,Vz] Vx=cos(ϕ)sin(θ)Vx=cos(\\phi)sin(\\theta)Vx=cos(ϕ)sin(θ) Vy=sin(ϕ)sin(θ)Vy=sin(\\phi)sin(\\theta)Vy=sin(ϕ)sin(θ) Vz=cos(θ)Vz=cos(\\theta)Vz=cos(θ) 正规矩阵 法线是垂直与点P切平面的矢量，如果知道了点P表面的切线T和双切线B，那么就可以使用叉乘计算出点P的法线N。 因为法线没有其次坐标，那么平移不影响到法向量，但是缩放和旋转操作就可能会影响到法线。 正规矩阵对原法向量进行了线性代数操作移除了对法向量的错误缩放效果。 在下图中，法向量通过Scale变换之后，与平面并不垂直了。 现在求取变换使得N经过model变换之后依然垂直与平面。 则N′=N∗M−1T N' = N * M^{-1 T}N​′​​=N∗M​−1T​​ 证明见链接 Copyright whpointz 2017 all right reserved，powered by GitbookThe revision time: 2017-11-07 17:48:25 "},"Volume_0_Mathematics_and_Physics_for_Computer_Graphics/0.1_Mathematical Foundations of Monte Carlo Methods.html":{"url":"Volume_0_Mathematics_and_Physics_for_Computer_Graphics/0.1_Mathematical Foundations of Monte Carlo Methods.html","title":"0.1_Mathematical Foundations of Monte Carlo Methods","keywords":"","body":" 蒙特卡洛方法的快速介绍 随机变量与概率 概率分布：第1部分 概率性质 统计概论 期望值 方差与标准差 概率分布：第2部分 抽样分布 概率密度函数和累积分布函数 随机变量函数的期望值 无意识统计 逆变换抽样方法 估计 蒙特卡洛方法的快速介绍 蒙特卡罗方法的快速介绍 蒙特卡罗是一类随机方法的统称。这类方法的特点是，可以在随机采样上计算得到近似结果，随着采样的增多，得到的结果是正确结果的概率逐渐加大，但在（放弃随机采样，而采用类似全采样这样的确定性方法）获得真正的结果之前，无法知道目前得到的结果是不是真正的结果。 人的身高可以被看成是一个随机变量，通常使用大写字母XXX来表示随机变量。 在统计数据中，构成随机变量集的元素，用小写字母xxx来表示。 那么我们就可以从n个样本中逼近人口的平均身高： Approximation(Average(X))=1N∑n=1Nxn.Approximation(Average(X)) = { 1 \\over N} \\sum_{n=1}^N x_n.Approximation(Average(X))=​N​​1​​∑​n=1​N​​x​n​​. 使用M来表示整个人口的大小，那么准确的人口平均身高为： E(X)=Average(X)=1M (x1+x2+...xM)E(X) = Average(X) = { 1 \\over M\\ } (x_1 + x_2 + ... x_M)E(X)=Average(X)=​M ​​1​​(x​1​​+x​2​​+...x​M​​) 蒙特卡洛近似是一种使用样本近似随机变量来得到期望的技术。可以使用下面公式： E(X)≈1N∑n=1Nxn.E(X) \\approx { 1 \\over N } \\sum_{n = 1}^N x_n.E(X)≈​N​​1​​∑​n=1​N​​x​n​​. 蒙特卡洛，偏向和无偏光线追踪 如图在光线追踪算法中，每个像素对应着场景中的一个区域。 这个像素最准确的颜色应该是对应的场景中的这个区域的积分： Lpixel=∫pixelareaL(xp)dAL_{pixel} = \\int_{pixel area} L(x_p) dAL​pixel​​=∫​pixelarea​​L(x​p​​)dA 但是没有一个方法可以实际上在像素对应着的场景表面进行积分，这个积分实际上没有解决方法。 但是我们可以使用“随机采样”来近似这个积分： 我们需要的是在像素区域中选择一些随机采样位置并平均其颜色。 Lpixel≈1N∑n=1NL(xn)L_{pixel} \\approx {1 \\over N } \\sum_{n=1}^N L(x_n)L​pixel​​≈​N​​1​​∑​n=1​N​​L(x​n​​) 蒙特卡洛方法是依靠随机抽样来近似结果的数值技术，特别是近似积分的结果。 蒙特卡洛绝对是渲染领域的核心。它与许多非常重要的其他主题相关，如采样，重要性采样，光传输算法等，并且还用于其他许多重要的渲染技术（尤其是阴影处理）。 随机变量与概率 概率分布：第1部分 概率性质 Copyright whpointz 2017 all right reserved，powered by GitbookThe revision time: 2017-11-07 21:20:50 "},"SourceCode/Geometry.html":{"url":"SourceCode/Geometry.html","title":" Geometry ","keywords":"","body":"通用矢量类的实现 template class Vec3 { public: Vec3() : x(0), y(0), z(0) {} Vec3(T xx) : x(xx), y(xx), z(xx) {} Vec3(T xx, T yy, T zz) : x(xx), y(yy), z(zz) {} Vec3 operator + (const Vec3 &v) const { return Vec3(x + v.x, y + v.y, z + v.z); } Vec3 operator - (const Vec3 &v) const { return Vec3(x - v.x, y - v.y, z - v.z); } Vec3 operator * (const T &r) const { return Vec3(x * r, y * r, z * r); } T dotProduct(const Vec3 &v) const { return x * v.x + y * v.y + z * v.z; } T crossProduct(const Vec3 &v) const { return Vec3(y * v.z - z * v.y, z * v.x - x * v.z, x * v.y - y * v.x); } T norm() const { return x * x + y * y + z * z; } T length() const { return sqrt(norm()); } const T& operator [] (uint8_t i) const { return (&x)[i]; } T& operator [] (uint8_t i) { return (&x)[i]; } Vec3& normalize() { T n = norm(); if (n > 0) { T factor = 1 / sqrt(n); x *= factor, y *= factor, z *= factor; } return *this; } friend std::ostream& operator &v) { return s Vec3f; typedef Vec3 Vec3i; Copyright whpointz 2017 all right reserved，powered by GitbookThe revision time: 2017-10-27 23:52:10 "}}