{"./":{"url":"./","title":"Introduction","keywords":"","body":"Scratchapixel-Notes Learn Computer Graphics From Scratch! Volume 0 Mathematics and Physics for Computer Graphics 0.0 Geometry 0.1_Mathematical Foundations of Monte Carlo Methods Copyright whpointz 2017 all right reserved，powered by GitbookThe revision time: 2017-11-07 21:29:03 "},"volume-0-mathematics-and-physics-for-computer-graphics.html":{"url":"volume-0-mathematics-and-physics-for-computer-graphics.html","title":"Volume 0 Mathematics and Physics for Computer Graphics","keywords":"","body":"几何学 几何是数学的一个分支，涉及了形状，尺寸，图像相对位置以及空间特征等问题。 关键词： 矢量 点 矩阵 正态 变换 笛卡尔坐标系 笛卡尔坐标 球坐标 坐标系 蒙特卡罗方法的数学基础 蒙特·卡罗方法（Monte Carlo method），也称统计模拟方法，是以概率统计理论为指导的一类非常重要的数值计算方法。 关键词： 蒙特卡罗方法 蒙特卡罗积分 随机变量 概率统计 期望值 方差 标准差 概率分布 概率密度函数 累积分布函数 逆变换抽样方法 估计量 Copyright whpointz 2017 all right reserved，powered by GitbookThe revision time: 2017-11-07 21:30:39 "},"Volume_0_Mathematics_and_Physics_for_Computer_Graphics/0.0_Geometry.html":{"url":"Volume_0_Mathematics_and_Physics_for_Computer_Graphics/0.0_Geometry.html","title":"0.0 Geometry","keywords":"","body":" 点、向量和法向量 坐标系统 关于点和向量的数学操作 矩阵 矩阵的原理：第1部分 矩阵的原理：第2部分 点和向量的移动 以行为主还是以列为主？ 矩阵操作 球坐标系和三角函数 正规矩阵 点、向量和法向量 一般情况下，点是三维空间中的一个位置，矢量是三维空间中的方向。三维的点和向量是类似的，都使用以下元组符号表示： V=(x,y,z)V = (x,y,z)V=(x,y,z) 齐次点(homogeneous points)，有时候为了数学上的方便，有必要使用 齐次坐标(homogeneous coordinates) 来表示点，齐次坐标中的点称为齐次点，齐次坐标的核心是将原本是一个n维的向量用一个n+1维向量来表示，优点是合并了矩阵运算中的乘法和加法（在矩阵运算中乘法一般对应着物体的缩放、旋转；加法一般对应着物体的移动）。 对于三维空间来说就是添加第四个元素www，得到三维空间下的齐次点。PH=(x,y,z,w)P_{H} = (x,y,z,w)P​H​​=(x,y,z,w) 法向量(Normals) 是描述几何对象表面上的一个点的方向。 在技术上，在点PPP处的法向量可以被看作是与该表面相切的平面的法向量。 坐标系统 笛卡尔坐标系(Cartesian coordinate system)，是直角坐标系和斜角坐标系的统称。 相交于原点的两条/三条/多条数轴，构成了平面放射坐标系。如果两条数轴上的度量单位相等，则称此放射性坐标系为笛卡尔坐标系。如果两条数轴相互垂直，则为笛卡尔直角坐标系，否则是笛卡尔斜角坐标系。 左手坐标系和右手坐标系 通常情况下不管是左手还是右手，中指都指向Z轴。 一般情况下，我们使用的都是右手坐标系：即X轴指向纸的右面，Y轴指向纸的上面，Z轴指向纸的外面，对应右手坐标系就是拇指是X，食指是Y，中指是Z。 在下面的动图中，绿色的轴是Y轴，红色的轴是X轴，蓝色的轴是Z轴。 关于点和向量的数学操作 向量的长度： ∣∣V∣∣=V.xV.x+V.yV.y+V.z∗V.z||V|| = \\sqrt{V.x_V.x + V.y_V.y + V.z*V.z}∣∣V∣∣=√​V.x​V​​.x+V.y​V​​.y+V.z∗V.z​​​ 归一化向量： V^=V∣∣V∣∣\\hat{V} = \\frac {V} {||V||}​V​^​​=​∣∣V∣∣​​V​​ 点积 数量积：一个向量在另一个向量上的投影，返回一个实数 A⋅B=A.xB.x+A.yB.y+A.zB.z=∣∣A∣∣∗∣∣B∣∣∗cos(θ)A {\\cdot} B = A.x B.x + A.y B.y + A.zB.z = ||A|| * ||B|| * cos(\\theta)A⋅B=A.xB.x+A.yB.y+A.zB.z=∣∣A∣∣∗∣∣B∣∣∗cos(θ) 使用点积的反余弦值可以得到两个向量之间的角度 θ\\thetaθ。 θ=cos−1(A⋅B∣∣A∣∣∗∣∣B∣∣)\\theta = cos^{-1}(\\frac{A \\cdot B}{||A|| * ||B||})θ=cos​−1​​(​∣∣A∣∣∗∣∣B∣∣​​A⋅B​​) 点积运算复合交换律、分配律和组合律。 叉乘 矢量积：叉乘为返回一个垂直于向量AAA和向量BBB的向量CCC，C=A×BC = A \\times BC=A×B 得到的结果向量的模 ∣C∣=∣A∣∗∣B∣∗sin(θ)|C| = |A| * |B| * sin(\\theta)∣C∣=∣A∣∗∣B∣∗sin(θ) 将 CCC 展开为 CX=AY∗BZ−AZ∗BYCY=AZ∗BX−AX∗BZCZ=AX∗BY−AY∗BX\r \\begin{array}{l}\r C_X = A_Y * B_Z - A_Z * B_Y \\\\\r C_Y = A_Z * B_X - A_X * B_Z \\\\\r C_Z = A_X * B_Y - A_Y * B_X \\\\\r \\end{array}\r ​C​X​​=A​Y​​∗B​Z​​−A​Z​​∗B​Y​​​C​Y​​=A​Z​​∗B​X​​−A​X​​∗B​Z​​​C​Z​​=A​X​​∗B​Y​​−A​Y​​∗B​X​​​​​ 叉乘没有交换律 A×B=CA\\times B = CA×B=C B×A=−CB\\times A = -CB×A=−C (1,0,0)×(0,1,0)=(0,0,1)(1,0,0)\\times (0,1,0) = (0,0,1)(1,0,0)×(0,1,0)=(0,0,1) (0,1,0)×(1,0,0)=(0,0,−1)(0,1,0)\\times (1,0,0) = (0,0,-1)(0,1,0)×(1,0,0)=(0,0,−1) 叉乘运算复合右手定则：向量CCC的方向为使用右手坐标系时向量AAA握拳到向量BBB时（握拳转动的角度不超过180°），大拇指所指的方向。 矩阵 一般我们使用 m∗nm*nm∗n 来描述一个矩阵的行和列（rows and columns），使用符号 MijM_{i j}M​ij​​ 描述矩阵M中的第 iii 行第 jjj 列的元素。 在CG中我们只要使用的是方阵，一般是 3∗33*33∗3 或者 4∗44*44∗4 。 矩阵相乘 的操作是点和向量矩阵变换过程的核心。矩阵乘法得到的结果是另一个矩阵。 矩阵相乘的时候，第一个矩阵的列必须等于第二个矩阵的行:[M×P]∗[P×N]=[M×N][M\\times P] * [P\\times N] = [M\\times N][M×P]∗[P×N]=[M×N] 矩阵乘法没有交换律。 但是矩阵乘法有结合律。 矩阵的原理：第1部分 教程中所讲的矩阵乘法都是右乘：即将矩阵写在乘号的右边，此时将向量看成是一行。 但在一些OpenGL使用的3D开源库（比如glm）中是左乘：即将矩阵写在乘号的左边，此时将向量看成是一列。 点和向量是三个数字的序列，因此将向量看成一行的话可以写成是1×31\\times 31×3的矩阵。 P=[xyz]P = \r \\left[\r \\begin{array}{cc} \r x & y & z\r \\end{array} \r \\right]P=[​x​​​y​​​z​​] 右乘：一个点 1×31\\times 31×3 乘于一个矩阵 3×33\\times 33×3 结果是一个点。 [xyz]∗[c00c01c02c10c11c12c20c21c22]\r \\begin{bmatrix}x & y & z\\end{bmatrix} *\r \\begin{bmatrix}\r c_{00}&c_{01}&{c_{02}}\\\\\r c_{10}&c_{11}&{c_{12}}\\\\\r c_{20}&c_{21}&{c_{22}}\\\\\r \\end{bmatrix}\r [​x​​​y​​​z​​]∗​⎣​⎢​⎢​⎡​​​c​00​​​c​10​​​c​20​​​​​​c​01​​​c​11​​​c​21​​​​​c​02​​​c​12​​​c​22​​​​​⎦​⎥​⎥​⎤​​ 单位矩阵 是一个方阵，除了对角线上的系数为1，别的系数都为0。 [100010001]\r \\begin{bmatrix}\r \\color{red}{1} & 0 & 0 \\\\\r 0 & \\color{red}{1} & 0 \\\\\r 0 & 0 & \\color{red}{1}\r \\end{bmatrix}\r ​⎣​⎡​​​1​0​0​​​0​1​0​​​0​0​1​​​⎦​⎤​​ 缩放矩阵Scale 是将点的坐标乘于一些实数，这样点的坐标就会产生缩放。 [SX000SY000SZ]\\begin{bmatrix}\r \\color{red}{S_X} & 0 & 0 \\\\\r 0 & \\color{red}{S_Y} & 0 \\\\\r 0 & 0 & \\color{red}{S_Z}\r \\end{bmatrix}​⎣​⎡​​​S​X​​​0​0​​​0​S​Y​​​0​​​0​0​S​Z​​​​​⎦​⎤​​ 旋转矩阵Rotate 将一个点或者是一个向量绕着坐标系的一个轴来旋转，这里讨论的仍然是右乘。即： PT=P∗R=[xyz]∗[R00R01R02R10R11R12R20R21R22] P_{T} = P * R = \\begin{bmatrix}x & y & z\\end{bmatrix} * \\begin{bmatrix} R_{00}&R_{01}&{R_{02}}\\\\ R_{10}&R_{11}&{R_{12}}\\\\ R_{20}&R_{21}&{R_{22}}\\\\ \\end{bmatrix} P​T​​=P∗R=[​x​​​y​​​z​​]∗​⎣​⎢​⎢​⎡​​​R​00​​​R​10​​​R​20​​​​​​R​01​​​R​11​​​R​21​​​​​R​02​​​R​12​​​R​22​​​​​⎦​⎥​⎥​⎤​​ PT.x=P.x∗R00+P.y∗R10+P.z∗R20PT.y=P.x∗R01+P.y∗R11+P.z∗R21PT.z=P.x∗R02+P.y∗R12+P.z∗R22 \\begin{array}{l} P_T.x = P.x * R_{00} + P.y * R_{10} + P.z * R_{20}\\\\ P_T.y = P.x * R_{01} + P.y * R_{11} + P.z * R_{21}\\\\ P_T.z = P.x * R_{02} + P.y * R_{12} + P.z * R_{22}\\\\ \\end{array} ​P​T​​.x=P.x∗R​00​​+P.y∗R​10​​+P.z∗R​20​​​P​T​​.y=P.x∗R​01​​+P.y∗R​11​​+P.z∗R​21​​​P​T​​.z=P.x∗R​02​​+P.y∗R​12​​+P.z∗R​22​​​​​ 三个轴上的旋转矩阵如下： Rx(θ)=[1000cos(θ)sin(θ)0−sin(θ)cos(θ)]R_{x}(\\theta) = \r \\left[ \r \\begin{array}{cc} \r 1 & 0 & 0 \\\\ \r 0 & cos(\\theta) & sin(\\theta) \\\\ \r 0 & -sin(\\theta) & cos(\\theta)\r \\end{array} \r \\right]R​x​​(θ)=​⎣​⎡​​​1​0​0​​​0​cos(θ)​−sin(θ)​​​0​sin(θ)​cos(θ)​​​⎦​⎤​​ Ry(θ)=[cos(θ)0−sin(θ)010sin(θ)0cos(θ)]R_{y}(\\theta) = \r \\left[ \r \\begin{array}{cc} \r cos(\\theta) & 0 & -sin(\\theta) \\\\ \r 0 & 1 & 0 \\\\ \r sin(\\theta) & 0 & cos(\\theta)\r \\end{array} \r \\right]R​y​​(θ)=​⎣​⎡​​​cos(θ)​0​sin(θ)​​​0​1​0​​​−sin(θ)​0​cos(θ)​​​⎦​⎤​​ Rz(θ)=[cos(θ)sin(θ)0−sin(θ)cos(θ)0001]R {z}(\\theta) = \r \\left[ \r \\begin{array}{cc} \r cos(\\theta) & sin(\\theta) & 0 \\\\ \r -sin(\\theta) & cos(\\theta)& 0 \\\\ \r 0 & 0 &1\r \\end{array} \r \\right]Rz(θ)=​⎣​⎡​​​cos(θ)​−sin(θ)​0​​​sin(θ)​cos(θ)​0​​​0​0​1​​​⎦​⎤​​ 平移矩阵Translate 必须要使用4×44\\times 44×4的变换矩阵才能解决这个问题。 组合矩阵 可以将RxR_{x}R​x​​ 和 RyR_{y}R​y​​ 组合成一个新的旋转矩阵。但是要注意组合的顺序，Rxy=Rx∗RyR_{xy} = R_{x} * R_{y}R​xy​​=R​x​​∗R​y​​，这个时候就是先旋转X轴然后旋转Y轴，一起组合成一个新的旋转。 比如想先缩放一个点，然后旋转一个点，矩阵分别为SSS和RRR。 当然在左乘和右乘里面的S和R是不一样的，互为转置矩阵。 左乘是 PT=[R∗(S∗P)]P_T = [R * (S * P)]P​T​​=[R∗(S∗P)] 右乘是 PT=[(P∗S)∗R]P_T = [(P * S) * R]P​T​​=[(P∗S)∗R] 要记住矩阵相乘有结合律。 矩阵的原理：第2部分 矩阵和直角坐标系的关系矩阵的每一行表示坐标系的轴（或者是基数）。 [c00c01c02c10c11c12c20c21c22]→x−axis→y−axis→z−axis\r \\begin{bmatrix}\r \\color{red}{c_{00}}& \\color{red}{c_{01}}&\\color{red}{c_{02}}\\\\\r \\color{green}{c_{10}}& \\color{green}{c_{11}}&\\color{green}{c_{12}}\\\\\r \\color{blue}{c_{20}}& \\color{blue}{c_{21}}&\\color{blue}{c_{22}}\\\\\r \\end{bmatrix}\r \\begin{array}{l}\r \\rightarrow \\quad \\color{red} {x-axis}\\\\\r \\rightarrow \\quad \\color{green} {y-axis}\\\\\r \\rightarrow \\quad \\color{blue} {z-axis}\\\\\r \\end{array}\r ​⎣​⎢​⎢​⎡​​​c​00​​​c​10​​​c​20​​​​​​c​01​​​c​11​​​c​21​​​​​c​02​​​c​12​​​c​22​​​​​⎦​⎥​⎥​⎤​​​→x−axis​→y−axis​→z−axis​​​ 比如旋转矩阵是这样的：Rz(θ)=[cos(θ)sin(θ)0−sin(θ)cos(θ)0001]R {z}(\\theta) = \r \\left[ \r \\begin{array}{cc} \r cos(\\theta) & sin(\\theta) & 0 \\\\\r -sin(\\theta) & cos(\\theta)& 0 \\\\\r 0 & 0 &1 \r \\end{array} \r \\right]Rz(θ)=​⎣​⎡​​​cos(θ)​−sin(θ)​0​​​sin(θ)​cos(θ)​0​​​0​0​1​​​⎦​⎤​​ 当我们使用旋转矩阵将点 P=[1,0,0]P=[1,0,0]P=[1,0,0] 绕z轴旋转 θ\\thetaθ 角度的时候，P^=[cos(θ),sin(θ),0]\\hat{P} = [cos(\\theta),sin(\\theta),0]​P​^​​=[cos(θ),sin(θ),0] 当我们使用旋转矩阵将点 P=[0,1,0]P=[0,1,0]P=[0,1,0] 绕z轴旋转 θ\\thetaθ 角度的时候，P^=[−sin(θ),cos(θ),0]\\hat{P} = [-sin(\\theta),cos(\\theta),0]​P​^​​=[−sin(θ),cos(θ),0] 则当我们使用旋转矩阵将点 P=[1,1,0]P=[1,1,0]P=[1,1,0] 绕z轴旋转 θ\\thetaθ 角度的时候，P^=[cos(θ)−sin(θ),sin(θ)+cos(θ),0]\\hat{P} = [cos(\\theta)-sin(\\theta),sin(\\theta)+cos(\\theta),0]​P​^​​=[cos(θ)−sin(θ),sin(θ)+cos(θ),0] 正交矩阵 正交矩阵使用 QQQ 来表示。正交矩阵的转置矩阵等于其逆矩阵。 QT=Q−1Q^{T} = Q^{-1}Q​T​​=Q​−1​​ QQT=IQQ^{T}=IQQ​T​​=I 正交矩阵的n个行或者列向量是n维空间的一组标准正交基。 点和向量的移动 点的移动，之前点的旋转以及点的缩放都可以直接使用3∗33*33∗3的矩阵来对1∗31*31∗3的点进行操作，但是当要对点进行移动操作时，必须使用4∗44*44∗4的矩阵来对1∗41*41∗4的点进行操作。 1∗41*41∗4 的点记作 [xyzw][xyzw][xyzw] ，一般情况下w为1。 乘于 4∗44*44∗4 的矩阵之后， P^.x=P.x∗M00+P.y∗M10+P.z∗M20+M30\\hat{P}.x = P.x*M_{00} + P.y*M_{10} + P.z*M_{20} + M_{30}​P​^​​.x=P.x∗M​00​​+P.y∗M​10​​+P.z∗M​20​​+M​30​​ P^.y=P.x∗M01+P.y∗M11+P.z∗M21+M31\\hat{P}.y = P.x*M_{01} + P.y*M_{11} + P.z*M_{21} + M_{31}​P​^​​.y=P.x∗M​01​​+P.y∗M​11​​+P.z∗M​21​​+M​31​​ P^.z=P.x∗M02+P.y∗M12+P.z∗M22+M32\\hat{P}.z = P.x*M_{02} + P.y*M_{12} + P.z*M_{22} + M_{32}​P​^​​.z=P.x∗M​02​​+P.y∗M​12​​+P.z∗M​22​​+M​32​​ P^.w=P.x∗M03+P.y∗M13+P.z∗M23+M33\\hat{P}.w = P.x*M_{03} + P.y*M_{13} + P.z*M_{23} + M_{33}​P​^​​.w=P.x∗M​03​​+P.y∗M​13​​+P.z∗M​23​​+M​33​​ 齐次点 点的w的存在就是为了归一化，当使用透视变换矩阵的时候，w会变成非1，这个时候需要对点P进行归一化，这样可以得到一个在笛卡尔坐标系中的点。 P'.x = P.x * M00 + P.y * M10 + P.z * M20 + M30; P'.y = P.x * M01 + P.y * M11 + P.z * M21 + M31; P'.z = P.x * M02 + P.y * M12 + P.z * M22 + M32; w' = P.x * M03 + P.y * M13 + P.z * M23 + M33; if (w' != 1 && w' != 0) { P'.x /= w', P'.y /= w', P'.z /= w'; } 以行为主还是以列为主？ 在之前通常把向量写成一行三列的形式： P=[xyz]P =\r \\left[ \r \\begin{array}{cc} \r x & y & z\r \\end{array} \r \\right]P=[​x​​​y​​​z​​] 也可以将向量写成三行一列的形式： P=[xyz]P =\r \\left[ \r \\begin{array}{cc} \r x \\\\\r y \\\\\r z\r \\end{array} \r \\right]P=​⎣​⎡​​​x​y​z​​​⎦​⎤​​ 以行为主或者是以列为主模式只是一个习惯。 当是一行三列的时候： [xyz]∗[C00C01C02C10C11C12C20C21C22]=[x′y′z′]\r \\left[ \r \\begin{array}{cc} \r x & y & z\r \\end{array} \r \\right] * \\left[ \r \\begin{array}{cc} \r C_{00} & C_{01} & C_{02} \\\\\r C_{10} & C_{11} & C_{12} \\\\\r C_{20} & C_{21} & C_{22}\r \\end{array} \r \\right] = \\left[ \r \\begin{array}{cc} \r x' & y' & z'\r \\end{array} \r \\right] [​x​​​y​​​z​​]∗​⎣​⎡​​​C​00​​​C​10​​​C​20​​​​​C​01​​​C​11​​​C​21​​​​​C​02​​​C​12​​​C​22​​​​​⎦​⎤​​=[​x​′​​​​​y​′​​​​​z​′​​​​] 当是三行一列的时候： [C00C01C02C10C11C12C20C21C22]∗[xyz]=[x′y′z′]\r \\left[ \r \\begin{array}{cc} \r C_{00} & C_{01} & C_{02} \\\\\r C_{10} & C_{11} & C_{12} \\\\\r C_{20} & C_{21} & C_{22}\r \\end{array} \r \\right] * \\left[ \r \\begin{array}{cc} \r x \\\\ y \\\\ z\r \\end{array} \r \\right] = \\left[ \r \\begin{array}{cc} \r x' \\\\ y' \\\\ z'\r \\end{array} \r \\right] ​⎣​⎡​​​C​00​​​C​10​​​C​20​​​​​C​01​​​C​11​​​C​21​​​​​C​02​​​C​12​​​C​22​​​​​⎦​⎤​​∗​⎣​⎡​​​x​y​z​​​⎦​⎤​​=​⎣​⎡​​​x​′​​​y​′​​​z​′​​​​​⎦​⎤​​ 若将左乘变成右乘，那么要对前面的变换矩阵CCC做出转置变成CTC^{T}C​T​​。 变换的结合顺序 若想对点PPP先使用变换矩阵TTT，然后绕Z轴旋转矩阵RzRzRz，然后绕Y轴旋转矩阵RyRyRy，得到点P′P'P​′​​。 使用一行三列的时候（被称为右乘）： P′=P∗T∗Rz∗RyP' = P * T * Rz * RyP​′​​=P∗T∗Rz∗Ry 使用三行一列的时候（被称为左乘）： P′=Ry∗Rz∗T∗PP' = Ry * Rz * T * PP​′​​=Ry∗Rz∗T∗P 矩阵的乘法符合结合律。 行主矩阵约定使得矩阵更易读，这就是我们将其用于Scratchapixel（以及Maya，DirectX）的原因。然而，一些3D API（如OpenGL）使用列主要约定。 矩阵操作 矩阵的转置MTM^{T}M​T​​ 矩阵的转置MTM^{T}M​T​​与矩阵MMM与主对角线对称，即MijT=MjiM^{T}_{ij} = M_{ji}M​ij​T​​=M​ji​​。 逆矩阵M−1M^{-1}M​−1​​ M∗M−1=IM*M^{-1} = IM∗M​−1​​=I 逆矩阵在3D变换中是一个很重要的概念，可以使用矩阵来转换点或者是向量，将变换之后的点或者向量恢复到变换之前的位置就需要逆矩阵。 正交矩阵： QT=Q−1Q^{T} = Q^{-1}Q​T​​=Q​−1​​ 不可逆矩阵称为奇异矩阵 球坐标系和三角函数 在线性代数中可以使用球面坐标来表示向量。 三角函数 角度制 θradians\\theta_{radians}θ​radians​​ 弧度制 θdegrees\\theta_{degrees}θ​degrees​​ 转换关系 θradians=π/180∗θdegrees\\theta_{radians} = \\pi / 180 * \\theta_{degrees}θ​radians​​=π/180∗θ​degrees​​ 二维坐标 与 弧度制 的相互转换： sin(θ)=Pxcos(θ)=Pytan(θ)=PyPx\r \\begin{array}{l}\r \\sin(\\theta)=P_x\\\\\r \\cos(\\theta)=P_y\\\\\r \\tan(\\theta)={P_y \\over P_x}\r \\end{array}\r ​sin(θ)=P​x​​​cos(θ)=P​y​​​tan(θ)=​P​x​​​​P​y​​​​​​ θ=acos(Px)θ=asin(Py)θ=atan2(Py,Px)\r \\begin{array}{l}\r \\theta = \\text{acos}(P_x)\\\\\r \\theta = \\text{asin}(P_y)\\\\\r \\theta = \\text{atan2}(P_y, P_x)\r \\end{array}\r ​θ=acos(P​x​​)​θ=asin(P​y​​)​θ=atan2(P​y​​,P​x​​)​​ 用球面坐标表示向量 用仰角和方位角两个角来表示向量。 (θ,ϕ)(\\theta,\\phi)(θ,ϕ) θ∈[0:π]\\theta \\in [0:\\pi]θ∈[0:π] ϕ∈[0:2π]\\phi \\in [0:2\\pi]ϕ∈[0:2π] 如下图所示： Z轴是向上的轴 在数学和物理中表示向量的惯例是将向上的轴命名为Z轴。和上图一样，使用的是左手坐标系。 已知点P的坐标为： P=[x,y,z,w]P = [x,y,z,w]P=[x,y,z,w] 坐标系的转换是一件相当麻烦的事情，有的时候需要一个转换矩阵： T=[1000001001000001]T = \r \\left[ \r \\begin{array}{cc} \r 1 & 0 & 0 & 0 \\\\\r 0 & 0 & 1 & 0 \\\\\r 0 & 1 & 0 & 0 \\\\\r 0 & 0 & 0 & 1 \r \\end{array} \r \\right]\r T=​⎣​⎢​⎢​⎡​​​1​0​0​0​​​0​0​1​0​​​0​1​0​0​​​0​0​0​1​​​⎦​⎥​⎥​⎤​​ 那么 P∗T=[x,z,y,w]P*T = [x,z,y,w]P∗T=[x,z,y,w] 这就是坐标系的转换。 将三维直角坐标系转换为球坐标 [Vx,Vy,Vz]−>(θ,ϕ)[Vx,Vy,Vz]->(\\theta,\\phi)[Vx,Vy,Vz]−>(θ,ϕ) θ=acos(Vz);\\theta = acos(Vz); θ=acos(Vz); ϕ=atan2(Vy,Vx);\\phi = atan2(Vy, Vx); ϕ=atan2(Vy,Vx); 球坐标到三维直角坐标 (θ,ϕ)−>[Vx,Vy,Vz](\\theta,\\phi)->[Vx,Vy,Vz](θ,ϕ)−>[Vx,Vy,Vz] Vx=cos(ϕ)sin(θ)Vx=cos(\\phi)sin(\\theta)Vx=cos(ϕ)sin(θ) Vy=sin(ϕ)sin(θ)Vy=sin(\\phi)sin(\\theta)Vy=sin(ϕ)sin(θ) Vz=cos(θ)Vz=cos(\\theta)Vz=cos(θ) 正规矩阵 法线 是垂直与点P切平面的矢量，如果知道了点P表面的切线T和双切线B，那么就可以使用叉乘计算出点P的法线N。 因为法线没有齐次坐标，那么平移不影响到法向量，但是缩放和旋转操作就可能会影响到法线。 正规矩阵 对原法向量进行了线性代数操作移除了对法向量的错误缩放效果。 在下图中，法向量通过Scale变换之后，与平面并不垂直了。 现在求取变换使得N经过model变换之后依然垂直与平面。 则 N′=N∗M−1TN'=N*M^{-1T}N​′​​=N∗M​−1T​​ 证明见链接 Copyright whpointz 2017 all right reserved，powered by GitbookThe revision time: 2018-01-19 11:19:52 "},"Volume_0_Mathematics_and_Physics_for_Computer_Graphics/0.1_Mathematical_Foundations_of_Monte_Carlo_Methods.html":{"url":"Volume_0_Mathematics_and_Physics_for_Computer_Graphics/0.1_Mathematical_Foundations_of_Monte_Carlo_Methods.html","title":"0.1_Mathematical Foundations of Monte Carlo Methods","keywords":"","body":" 蒙特卡洛方法的快速介绍 随机变量与概率 概率分布：第1部分 概率性质 统计概论 期望值 方差与标准差 概率分布：第2部分 抽样分布 概率密度函数和累积分布函数 随机变量函数的期望值 无意识统计 逆变换抽样方法 估计 蒙特卡洛方法的快速介绍 蒙特卡罗方法的快速介绍 蒙特卡罗是一类随机方法的统称。这类方法的特点是，可以在随机采样上计算得到近似结果，随着采样的增多，得到的结果是正确结果的概率逐渐加大，但在（放弃随机采样，而采用类似全采样这样的确定性方法）获得真正的结果之前，无法知道目前得到的结果是不是真正的结果。 人的身高可以被看成是一个随机变量，通常使用大写字母 XXX 来表示 随机变量 。 在统计数据中，构成随机变量集的元素，用小写字母 xxx 来表示。 那么我们就可以从 nnn 个样本中逼近人口的平均身高： Approximation(Average(X))=1N∑n=1Nxn.Approximation(Average(X)) = { 1 \\over N} \\sum_{n=1}^N x_n.Approximation(Average(X))=​N​​1​​∑​n=1​N​​x​n​​. 使用 MMM 来表示整个人口的大小，那么准确的人口平均身高的期望值 E(X)E(X)E(X) 为： E(X)=Average(X)=1M (x1+x2+...xM)E(X) = Average(X) = { 1 \\over M\\ } (x_1 + x_2 + ... x_M)E(X)=Average(X)=​M ​​1​​(x​1​​+x​2​​+...x​M​​) 蒙特卡洛近似 是一种使用样本近似随机变量来得到期望的技术。可以使用下面公式在数学上定义： E(X)≈1N∑n=1Nxn.E(X) \\approx { 1 \\over N } \\sum_{n = 1}^N x_n.E(X)≈​N​​1​​∑​n=1​N​​x​n​​. 蒙特卡洛，偏向和无偏光线追踪 在数码相机拍照中，如果将图像的表面划分为规则的网格，那么每一个像素都对应着场景中的一个区域。这个区域中的多个对象被转换为单一的像素颜色。 理想的情况下，为了得到这个元素的颜色，我们要做的是计算通过这个像素的总光量。我们可以用以下的数学公式来表达这个观点: Lpixel=∫pixelareaL(xp)dAL_{pixel} = \\int_{pixel area} L(x_p) dAL​pixel​​=∫​pixelarea​​L(x​p​​)dA 但是没有一个方法可以实际上在像素对应着的场景表面进行积分，这个积分实际上没有解决方法。 但是我们可以使用“随机采样”来近似这个积分： 我们需要的是在像素区域中选择一些随机采样位置并平均其颜色。 Lpixel≈1N∑n=1NL(xn)L_{pixel} \\approx {1 \\over N } \\sum_{n=1}^N L(x_n)L​pixel​​≈​N​​1​​∑​n=1​N​​L(x​n​​) 我们计算 E(X)E(X)E(X) 的近似值的规则称为估计量。等式： Approximation(E(X))=1N∑n=1Nxn,Approximation(E(X)) = { 1 \\over N } \\sum_{n=1}^N x_n,Approximation(E(X))=​N​​1​​∑​n=1​N​​x​n​​, 如果 估计量 随着 样本量N 的增加而越接近 期望值 ，则估计量就是无偏的。 Approximation(E(X))−E(X)=0 as N approaches ∞. Approximation(E(X)) - E(X) = 0 \\text { as N approaches } \\infty. Approximation(E(X))−E(X)=0 as N approaches ∞. 蒙特卡洛估计是一个无偏估计量。 蒙特卡洛方法是依靠随机抽样来近似结果的数值技术，特别是近似积分的结果。 蒙特卡洛绝对是渲染领域的核心。它与许多非常重要的其他主题相关，如采样，重要性采样，光传输算法等，并且还用于其他许多重要的渲染技术（尤其是阴影处理）。 随机变量与概率 可以使用数学符号表示硬币正面或者反面的概率： X(ω)={1,if  ω=heads,0,if  ω=tails.\r X(\\omega) =\r \\begin{cases}\r 1, & \\text{if} \\ \\ \\omega = \\text{heads} , \\\\\r \\\\\r 0, & \\text{if} \\ \\ \\omega = \\text{tails} .\r \\end{cases}\r X(ω)=​⎩​⎪​⎨​⎪​⎧​​​1,​​0,​​​if  ω=heads,​if  ω=tails.​​ $X$ 就是随机变量，是一个关于ω\\omegaω的函数，ω\\omegaω是随机过程的结果。 也就是说，随机变量不是一个固定的值，而是一个函数，将随机过程的可能结果（硬币的正面或者反面）映射到数字0或者1。 随机过程 的定义是产生不可预测的结果，然而 概率 可以用来描述随机过程中发生特定事件的机会。 术语： 大写字母 X,Y,Z...X,Y,Z...X,Y,Z... 来表示随机变量函数 小写字母 x,y,z...x,y,z...x,y,z... 表示观测结果 使用S={1,2,3,4,5,6}S = \\{1, 2, 3, 4, 5, 6\\}S={1,2,3,4,5,6} 表示样本空间 使用 x1,x2,...,xnx_1,x_2,...,x_nx​1​​,x​2​​,...,x​n​​ 表示事件 事件 是 样本空间 的子集 概率分布：第1部分 离散的随机变量分布使用散点来表示，连续的随机变量分布使用曲线来表示。 二项分布 当一个随机过程只有两个结果（比如“头”或“尾”，“成功”或“失败”）时，我们会谈论伯努利（或二项式）试验。 比如：抛硬币6次，那么得到4个头的概率是多少？ Pr(S=n)=CnNpk(1−p)(N−n)Pr(S = n) = C_n^N p^k(1-p)^{(N-n)}Pr(S=n)=C​n​N​​p​k​​(1−p)​(N−n)​​ 正态分布 正态分布与二项分布非常相似，但二项分布适用于 离散随机变量 ，正态分布适用于 连续随机变量。 概率性质 相互排斥和集体穷举的事件 样本空间的定理和属性与集合类似。 比如当样本空间A={1,2,3}A=\\{1,2,3\\}A={1,2,3}，样本空间B={3,4,5}B=\\{3,4,5\\}B={3,4,5}，A和B是两个不相交的集合，那么样本空间对应的事件就是不能同时发生的，或者说是互斥的。 互斥事件和相互独立事件 互斥事件一起发生的概率： Pr(A∩B)=0Pr(A \\cap B) = 0Pr(A∩B)=0 独立事件一起发生的概率： Pr(A∩B)=Pr(A)Pr(B)Pr(A \\cap B) = Pr(A)Pr(B)Pr(A∩B)=Pr(A)Pr(B) 概率性质 事件A(A为样本空间可能的结果之一)发生的概率为Pr(A)Pr(A)Pr(A)，Pr(A)Pr(A)Pr(A)需要实际满足三个公理： 对于每个事件A，Pr(A)≥0Pr(A) \\ge 0Pr(A)≥0 如果一个事件肯定会发生，那么该事件的概率是1。 任何互相排斥的E1,E2,...E1,E2,...E1,E2,... 事件的发生的概率(E1发生 或者 E2发生 或者 ...)满足：Pr(E1∪E2∪...)=∑i=1∞Pr(Ei).Pr(E_1 \\cup E_2 \\cup \\;...) = \\sum_{i=1}^\\infty Pr(E_i).Pr(E​1​​∪E​2​​∪...)=∑​i=1​∞​​Pr(E​i​​). 统计概论 我们不知道10张牌中有多少张牌的数字是0,1或2。总之，我们不知道这个实验产生的随机变量，除了返回数字在0到2之间，我们对这些数字的概率分布一无所知，因此我们不能用 概率计算 来估计获得0或2的概率。但我们可以猜测吗？答案是肯定的，这正是 统计 的目标。 统计的目标是提供关于 随机变量 和 概率分布 的信息，这些信息我们一开始是不知道的。 期望值 平均值或者算术平均值 是一个简单的概念，只需要对数据进行累加，然后除于数据的个数即可。 μ=1N(v1+v2+...+vN).\\mu = \\dfrac{1}{N} (v_1 + v_2 + ... + v_N).μ=​N​​1​​(v​1​​+v​2​​+...+v​N​​). 一个结果和概率已知的实验的 期望值 可以通过将 样本空间的值 乘以它们个体的 概率 累加起来计算得出。 平均值 和 期望值 是相等的，然而 平均值 是没有任何加权的数字的简单平均值，而 期望值 是通过它们各自概率加权的数字的总和。 EV=∑i=1Npixi.EV = \\sum_{i=1}^N p_i x_i.EV=∑​i=1​N​​p​i​​x​i​​. 在卡片的例子中，其平均值和期望值各自如下： μ=(0+0+1+1+1+1+1+2+2+2)10=1.1,EV=0∗0.2+1∗0.5+2∗0.3=1.1.\\begin{array}{l}\r \\mu &=&\\dfrac{(0+0+1+1+1+1+1+2+2+2)}{10}=1.1, \\\\\r EV&=&0 * 0.2 + 1 * 0.5 + 2 * 0.3=1.1.\r \\end{array}​μ​EV​​​=​=​​​​10​​(0+0+1+1+1+1+1+2+2+2)​​=1.1,​0∗0.2+1∗0.5+2∗0.3=1.1.​​ 样本均值 在大多数的情况下，实验的概率分布和结果是不知道的，此时需要利用 随机采样 对概率的分布进行估计。随机变量 XXX 产生的观测值的集合被称为 样本均值 X¯\\bar X​X​¯​​ 。 X¯n=1n(X1+X2+...+Xn) =1n(x1+x2+...+xn) =1n(X1(ω)+X2(ω)+...+Xn(ω).\\bar X_n = \\dfrac{1}{n} (X_1 + X_2 + ... + X_n) \\ = {1 \\over n } (x_1+x_2+...+x_n) \\ = {1 \\over n} (X_1(\\omega)+X_2(\\omega) + ... + X_n(\\omega).​X​¯​​​n​​=​n​​1​​(X​1​​+X​2​​+...+X​n​​) =​n​​1​​(x​1​​+x​2​​+...+x​n​​) =​n​​1​​(X​1​​(ω)+X​2​​(ω)+...+X​n​​(ω). 大写字母X1X2X_1 X_2X​1​​X​2​​ 是一系列随机变量，它们的性质是独立分布的。 随机变量XXX实例上是从 样本空间S 到 实数空间R 的一个函数。 小写字母x1x2x_1 x_2x​1​​x​2​​ 是一些列观察值，即x=X(ω)x = X(\\omega)x=X(ω)。 随着样本规模的增加，样本均值 收敛于 期望值 ： X¯n≈EV.\\bar X_n \\approx EV.​X​¯​​​n​​≈EV. 随着我们不断增加试验次数，随机变量的样本均值 X¯n\\bar X_n​X​¯​​​n​​ 趋近于一个极限，这个极限是 随机变量的期望值E(X)E(X)E(X)。 随机变量的期望值 E(X)E(X)E(X) 和总体均值 μ\\muμ 是相等的。 X¯n→E[X]=μ as n→∞.\\bar X_n \\rightarrow E[X] = \\mu \\text{ as } n \\rightarrow \\infty.​X​¯​​​n​​→E[X]=μ as n→∞. 概率收敛： limn→∞ Pr (∣X¯n−μ∣ϵ)=1.\\begin{array}{l} \\lim_{n \\rightarrow \\infty} \\text{ Pr }(|\\bar X_n - \\mu| ​lim​n→∞​​ Pr (∣​X​¯​​​n​​−μ∣ϵ)=1.​​ 随机变量的 样本均值 X¯n\\bar X_n​X​¯​​​n​​ 概率收敛于随机样本所在群体的 总体平均值 μ\\muμ . 方差与标准差 标准差 是 方差Variance 的平方根，方差可以表示为： Var(X)=σ2=E[(X−E[X])2]=∑i(xi−E[X])2pi.Var(X) = \\sigma^2 = E[(X - E[X])^2] = \\sum_i (x_i - E[X])^2p_i.Var(X)=σ​2​​=E[(X−E[X])​2​​]=∑​i​​(x​i​​−E[X])​2​​p​i​​. 方差的表示式可以扩展为： E[(X−E[X])2]=E[(X−μ)2]=E[X2+μ2−2Xμ]=E[X2]−2E[X]μ+E[μ2]=E[X2]−2μ2+μ2=E[X2]−μ2=∑ixi2pi−(∑ixipi)2=∑ixi2pi−μ2.\\begin{array}{l}\r E[(X - E[X])^2] & = & E[(X - \\mu)^2] \\\\ \r & = & E[X^2 + \\mu^2 - 2 X\\mu] \\\\ \r & = & E[X^2] -2E[X]\\mu + E[\\mu^2] \\\\ \r & = & E[X^2] - 2\\mu^2 + \\mu^2 \\\\ \r & = & E[X^2] - \\mu^2 \\\\ \r & = & \\sum_i x_i^2 p_i - (\\sum_i x_i p_i)^2 \\\\ \r & = & \\sum_i x_i^2 p_i - \\mu^2.\r \\end{array}​E[(X−E[X])​2​​]​​​​​​​​​=​=​=​=​=​=​=​​​E[(X−μ)​2​​]​E[X​2​​+μ​2​​−2Xμ]​E[X​2​​]−2E[X]μ+E[μ​2​​]​E[X​2​​]−2μ​2​​+μ​2​​​E[X​2​​]−μ​2​​​∑​i​​x​i​2​​p​i​​−(∑​i​​x​i​​p​i​​)​2​​​∑​i​​x​i​2​​p​i​​−μ​2​​.​​ 如果所有的随机变量具有相同的概率： Var(X)=∑i=1n(xi−X¯)2n.Var(X) = \\sum_{i=1}^n{ { (x_i - \\bar X)^2} \\over n }.Var(X)=∑​i=1​n​​​n​​(x​i​​−​X​¯​​)​2​​​​. 方差的属性可以通过 期望的四个公式 以及 一个方差公式 推出： E[X+c]=E[X]+c,E[cX]=cE[X],E[X+Y]=E[X]+E[Y],E[E[X]=E[X].\\begin{array}{l}\r E[X + c] = E[X] + c, \\\\ E[cX] = c E[X], \\\\ E[X +Y] = E[X]+E[Y], \\\\ E[E[X] = E[X].\r \\end{array}​E[X+c]=E[X]+c,​E[cX]=cE[X],​E[X+Y]=E[X]+E[Y],​E[E[X]=E[X].​​ Var(X)=E[(X−E[X])2]=E[X2−2XE[X]+E[X]2],=E[X2]−2E[X]E[X]+E[X]2,=E[X2]−E[X]2.\r \\begin{array}{l}\r Var(X) &=& E[(X - E[X])^2] \\\\ & =& E[X^2 - 2X E[X] + E[X]^2], \\\\ \r & =& E[X^2] - 2 E[X] E[X] + E[X]^2, \\\\ \r & =& E[X^2] - E[X]^2.\r \\end{array}\r ​Var(X)​​​​​​=​=​=​=​​​E[(X−E[X])​2​​]​E[X​2​​−2XE[X]+E[X]​2​​],​E[X​2​​]−2E[X]E[X]+E[X]​2​​,​E[X​2​​]−E[X]​2​​.​​ 概率分布：第2部分 Copyright whpointz 2017 all right reserved，powered by GitbookThe revision time: 2018-01-22 12:21:37 "},"SourceCode/Geometry.html":{"url":"SourceCode/Geometry.html","title":" Geometry ","keywords":"","body":"通用矢量类的实现 template class Vec3 { public: Vec3() : x(0), y(0), z(0) {} Vec3(T xx) : x(xx), y(xx), z(xx) {} Vec3(T xx, T yy, T zz) : x(xx), y(yy), z(zz) {} Vec3 operator + (const Vec3 &v) const { return Vec3(x + v.x, y + v.y, z + v.z); } Vec3 operator - (const Vec3 &v) const { return Vec3(x - v.x, y - v.y, z - v.z); } Vec3 operator * (const T &r) const { return Vec3(x * r, y * r, z * r); } T dotProduct(const Vec3 &v) const { return x * v.x + y * v.y + z * v.z; } T crossProduct(const Vec3 &v) const { return Vec3(y * v.z - z * v.y, z * v.x - x * v.z, x * v.y - y * v.x); } T norm() const { return x * x + y * y + z * z; } T length() const { return sqrt(norm()); } const T& operator [] (uint8_t i) const { return (&x)[i]; } T& operator [] (uint8_t i) { return (&x)[i]; } Vec3& normalize() { T n = norm(); if (n > 0) { T factor = 1 / sqrt(n); x *= factor, y *= factor, z *= factor; } return *this; } friend std::ostream& operator &v) { return s Vec3f; typedef Vec3 Vec3i; Copyright whpointz 2017 all right reserved，powered by GitbookThe revision time: 2017-10-27 23:52:10 "}}