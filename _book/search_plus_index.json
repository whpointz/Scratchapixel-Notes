{"./":{"url":"./","title":"Introduction","keywords":"","body":"Scratchapixel-Notes Learn Computer Graphics From Scratch! Volume 0 Mathematics and Physics for Computer Graphics 0.0 Geometry Copyright whpointz 2017 all right reserved，powered by GitbookThe revision time: 2017-10-26 20:23:02 "},"volume-0-mathematics-and-physics-for-computer-graphics.html":{"url":"volume-0-mathematics-and-physics-for-computer-graphics.html","title":"Volume 0 Mathematics and Physics for Computer Graphics","keywords":"","body":" 几何是数学的一个分支，涉及了形状，尺寸，图像相对位置以及空间特征等问题。 关键词： 矢量 点 矩阵 正态 变换 笛卡尔坐标系 笛卡尔坐标 球坐标 坐标系 Copyright whpointz 2017 all right reserved，powered by GitbookThe revision time: 2017-10-27 21:35:44 "},"Volume_0_Mathematics_and_Physics_for_Computer_Graphics/0.1_Geometry.html":{"url":"Volume_0_Mathematics_and_Physics_for_Computer_Graphics/0.1_Geometry.html","title":"0.0 Geometry","keywords":"","body":"Points, Vectors and Normals 一般情况下，点是三维空间中的一个位置，矢量是三维空间中的方向。三维的点和向量是类似的，都使用以下元组符号表示： V=(x,y,z)V = (x,y,z)V=(x,y,z) homogeneous points，有时候为了数学上的方便，有必要添加第四个元素，这就是均匀点。PH=(x,y,z,w)P_{H} = (x,y,z,w)P​H​​=(x,y,z,w) 法向量是描述几何对象在该表面上的一个点的方向。在技术上，在点P处的法线可以被看作是与该表面相切的平面的法线。 Coordinate Systems 笛卡尔坐标系(Cartesian coordinate system)，x轴和y轴相互垂直。 欧几里得空间(Euclidean space)，在x轴和y轴的基础上添加表示深度的z轴。 左手坐标系或者右手坐标系通常情况下是通过左手或者是右手的中指指向Z轴。一般情况下，我们使用的都是右手坐标系：即Z轴指向上，X轴指向右，Y轴指向纸的外面，对应右手坐标系就是拇指是X，食指是Y，中指是Z。 Math Operations on Points and Vectors 向量的长度： ∣∣V∣∣=V.xV.x+V.yV.y+V.z∗V.z||V|| = \\sqrt{V.x_V.x + V.y_V.y + V.z*V.z}∣∣V∣∣=√​V.x​V​​.x+V.y​V​​.y+V.z∗V.z​​​ 归一化向量： V^=V∣∣V∣∣\\hat {V} = \\frac {V} {||V||}​V​^​​=​∣∣V∣∣​​V​​ 点积：一个向量到另一个向量上的投影，返回一个实数A⋅B=A.xB.x+A.yB.y+A.zB.z=∣∣A∣∣∗∣∣B∣∣∗cos(θ)A {\\cdot} B = A.x B.x + A.y B.y + A.zB.z = ||A|| * ||B|| * cos(\\theta)A⋅B=A.xB.x+A.yB.y+A.zB.z=∣∣A∣∣∗∣∣B∣∣∗cos(θ) 当两个向量被归一化的时候，使用点积的反余弦值可以得到两个向量之间的角度 θ\\thetaθ。θ=cos−1(A⋅B∣∣A∣∣∗∣∣B∣∣)\\theta = cos^{-1}(\\frac{A \\cdot B}{||A|| * ||B||})θ=cos​−1​​(​∣∣A∣∣∗∣∣B∣∣​​A⋅B​​) 叉乘：叉乘为返回一个垂直于向量AAA和向量BBB的向量CCC，C=A×BC = A \\times BC=A×B 将CCC展开为 CX=AYBZ−AZBYC_{X} = A_{Y} B_{Z} - A_{Z} B_{Y}C​X​​=A​Y​​B​Z​​−A​Z​​B​Y​​ CY=AZBX−AXBZC_{Y} = A_{Z} B_{X} - A_{X} B_{Z}C​Y​​=A​Z​​B​X​​−A​X​​B​Z​​ CZ=AXBY−AYBXC_{Z} = A_{X} B_{Y} - A_{Y} B_{X}C​Z​​=A​X​​B​Y​​−A​Y​​B​X​​ 叉乘没有交换律 A×B=CA\\times B = CA×B=C B×A=−CB\\times A = -CB×A=−C (1,0,0)×(0,1,0)=(0,0,1)(1,0,0)\\times (0,1,0) = (0,0,1)(1,0,0)×(0,1,0)=(0,0,1) (0,1,0)×(1,0,0)=(0,0,−1)(0,1,0)\\times (1,0,0) = (0,0,-1)(0,1,0)×(1,0,0)=(0,0,−1) 向量CCC的方向为使用右手坐标系时向量AAA握拳到向量BBB时，大拇指所指的方向。 Matrices 一般我们使用m∗nm * nm∗n来描述一个矩阵的行和列（rows and columns），使用符号 MijM {i j}Mij 描述矩阵M中的第iii行第jjj列的元素。 在CG中我们只要使用的是方阵，一般是333 333或者444 444。 矩阵相乘的操作是点和向量矩阵变换过程的核心。矩阵乘法的结果是另一个矩阵。 矩阵相乘的时候，第一个矩阵的列必须等于第二个矩阵的行:[M×P]∗[P×N]=[M×N][M\\times P] * [P\\times N] = [M\\times N][M×P]∗[P×N]=[M×N] 矩阵乘法没有交换律。 How Does Matrix Work: Part 1 教程中所讲的矩阵乘法都是右乘：即将矩阵写在乘号的右边，此时将向量看成是一行。 但在一些OpenGL使用的3D开源库（比如glm）中是左乘：即将矩阵写在乘号的左边，此时将向量看成是一列。 点和向量是三个数字的序列，因此可以写成是1×31\\times 31×3的矩阵。 P=(xyz )=[xyz]P = \r \\left( \r \\begin{array}{cc} \r x y z \\ \r \\end{array} \r \\right) = \\left[ x y z \\right]P=(​xyz ​​)=[xyz] 一个点乘于一个矩阵结果是一个点。 [xyz]∗[C00C01C02C10C11C12C20C21C22]\\left[ x y z \\right] * \r \\left[ \r \\begin{array}{cc} \r C_{00} & C_{01} & C_{02} \\\\\r C_{10} & C_{11} & C_{12} \\\\\r C_{20} & C_{21} & C_{22} \\\\ \r \\end{array} \r \\right][xyz]∗​⎣​⎢​⎢​⎡​​​C​00​​​C​10​​​C​20​​​​​​C​01​​​C​11​​​C​21​​​​​C​02​​​C​12​​​C​22​​​​​⎦​⎥​⎥​⎤​​ 单位矩阵是一个方阵，除了对角线上的系数为1，别的系数都为0。 缩放矩阵Scale是将点的坐标乘于一些实数，这样导致了点的坐标的缩放。 [Sx000Sy000Sz]\\left[ \r \\begin{array}{cc} \r S{x} & 0 & 0 \\\\\r 0 & S{y} & 0 \\\\ \r 0 & 0 & S_{z} \\\\ \r \\end{array} \r \\right]​⎣​⎢​⎢​⎡​​​Sx​0​0​​​​0​Sy​0​​​0​0​S​z​​​​​⎦​⎥​⎥​⎤​​ 旋转矩阵Rotate\\将一个点或者是一个向量绕着坐标系的一个轴来旋转。 Rx(θ)=[1000cos(θ)sin(θ)0−sin(θ)cos(θ)]R_{x}(\\theta) = \r \\left[ \r \\begin{array}{cc} \r 1 & 0 & 0 \\\\ \r 0 & cos(\\theta) & sin(\\theta) \\\\ \r 0 & -sin(\\theta) & cos(\\theta) \\\\ \r \\end{array} \r \\right]R​x​​(θ)=​⎣​⎢​⎢​⎡​​​1​0​0​​​​0​cos(θ)​−sin(θ)​​​0​sin(θ)​cos(θ)​​​⎦​⎥​⎥​⎤​​ Ry(θ)=[cos(θ0−sin(θ)010sin(θ)0cos(θ)]R_{y}(\\theta) = \r \\left[ \r \\begin{array}{cc} \r cos(\\theta & 0 & -sin(\\theta) \\\\ \r 0 & 1 & 0 \\\\ \r sin(\\theta) & 0 & cos(\\theta) \\\\ \r \\end{array} \r \\right]R​y​​(θ)=​⎣​⎢​⎢​⎡​​​cos(θ​0​sin(θ)​​​​0​1​0​​​−sin(θ)​0​cos(θ)​​​⎦​⎥​⎥​⎤​​ Rz(θ)=[cos(θ)sin(θ)0−sin(θ)cos(θ)0001]R {z}(\\theta) = \r \\left[ \r \\begin{array}{cc} \r cos(\\theta) & sin(\\theta) & 0 \\\\ \r -sin(\\theta) & cos(\\theta)& 0 \\\\ \r 0 & 0 &1\\\\ \r \\end{array} \r \\right]Rz(θ)=​⎣​⎢​⎢​⎡​​​cos(θ)​−sin(θ)​0​​​​sin(θ)​cos(θ)​0​​​0​0​1​​​⎦​⎥​⎥​⎤​​ 平移矩阵Translate 必须要使用4×44\\times 44×4的变换矩阵才能解决这个问题。 组合矩阵 可以将RxR_{x}R​x​​ 和 RyR_{y}R​y​​ 组合成一个新的旋转矩阵。但是要注意组合的顺序，Rxy=Rx∗RyR_{xy} = R_{x} * R {y}R​xy​​=R​x​​∗Ry，这个时候就是先旋转X轴然后旋转Y轴，一起组合成一个新的旋转。 在之前的学习过程中，我一直错误的理解了矩阵的左乘和右乘，比如想先缩放一个点，然后旋转一个点，矩阵分别为SSS和RRR。 左乘是 P^=S∗R∗P\\hat{P} = S * R * P​P​^​​=S∗R∗P(左乘之前以为是 P^=R∗S∗P\\hat{P} = R * S * P​P​^​​=R∗S∗P) 右乘是 P^=P∗S∗R\\hat{P} = P * S * R​P​^​​=P∗S∗R 要记住不管是左乘还是右乘，其实都是按照从左到右的顺序来计算矩阵的。 How Does Matrix Work: Part 2 矩阵和坐标系的关系矩阵的每一行表示坐标系的轴（或者是基数）。 比如旋转矩阵是这样的：Rz(θ)=[cos(θ)sin(θ)0−sin(θ)cos(θ)0001]R {z}(\\theta) = \r \\left[ \r \\begin{array}{cc} \r cos(\\theta) & sin(\\theta) & 0 \\\\\r -sin(\\theta) & cos(\\theta)& 0 \\\\\r 0 & 0 &1 \\\\ \r \\end{array} \r \\right]Rz(θ)=​⎣​⎢​⎢​⎡​​​cos(θ)​−sin(θ)​0​​​​sin(θ)​cos(θ)​0​​​0​0​1​​​⎦​⎥​⎥​⎤​​ 当我们使用旋转矩阵将点P=[1,0,0]P=[1,0,0]P=[1,0,0] 绕z轴旋转 θ\\thetaθ角度的时候，P^=[cos(θ),sin(θ),0]\\hat{P} = [cos(\\theta),sin(\\theta),0]​P​^​​=[cos(θ),sin(θ),0] 当我们使用旋转矩阵将点P=[0,1,0]P=[0,1,0]P=[0,1,0] 绕z轴旋转 θ\\thetaθ角度的时候，P^=[−sin(θ),cos(θ),0]\\hat{P} = [-sin(\\theta),cos(\\theta),0]​P​^​​=[−sin(θ),cos(θ),0] 当我们使用旋转矩阵将点P=[1,1,0]P=[1,1,0]P=[1,1,0] 绕z轴旋转 θ\\thetaθ角度的时候，P^=[cos(θ)−sin(θ),sin(θ)+cos(θ),0]\\hat{P} = [cos(\\theta)-sin(\\theta),sin(\\theta)+cos(\\theta),0]​P​^​​=[cos(θ)−sin(θ),sin(θ)+cos(θ),0] 正交矩阵\\正交矩阵使用Q来表示 QT=Q−1Q^{T} = Q^{-1}Q​T​​=Q​−1​​ QQT=IQQ^{T}=IQQ​T​​=I Transforming Points and Vectors 点的移动，之前点的旋转以及点的缩放都可以直接使用3∗33*33∗3的矩阵来对1∗31*31∗3的点进行操作，但是当要对点进行移动操作时，必须使用4∗44*44∗4的矩阵来对1∗41*41∗4的点进行操作。 1∗41*41∗4的点记作[xyzw][x y z w][xyzw]，一般情况下w为1。 乘于4∗44*44∗4的矩阵之后， P^.x=P.x∗M00+P.y∗M10+P.z∗M20+M30\\hat{P}.x = P.x*M_{00} + P.y*M_{10} + P.z*M_{20} + M_{30}​P​^​​.x=P.x∗M​00​​+P.y∗M​10​​+P.z∗M​20​​+M​30​​ P^.y=P.x∗M01+P.y∗M11+P.z∗M21+M31\\hat{P}.y = P.x*M_{01} + P.y*M_{11} + P.z*M_{21} + M_{31}​P​^​​.y=P.x∗M​01​​+P.y∗M​11​​+P.z∗M​21​​+M​31​​ P^.z=P.x∗M02+P.y∗M12+P.z∗M22+M32\\hat{P}.z = P.x*M_{02} + P.y*M_{12} + P.z*M_{22} + M_{32}​P​^​​.z=P.x∗M​02​​+P.y∗M​12​​+P.z∗M​22​​+M​32​​ P^.w=P.x∗M03+P.y∗M13+P.z∗M23+M33\\hat{P}.w = P.x*M_{03} + P.y*M_{13} + P.z*M_{23} + M_{33}​P​^​​.w=P.x∗M​03​​+P.y∗M​13​​+P.z∗M​23​​+M​33​​ 齐次点 点的w的存在就是为了归一化，当使用透视变换矩阵的时候，w会变成非1，这个时候需要对P进行归一化，这样可以得到一个在笛卡尔坐标系中使用的点。 Row Major vs Column Major Vector 在之前通常把向量写成一行三列的形式： P=[xyz]P =\r \\left[ \r \\begin{array}{cc} \r x & y & z\r \\end{array} \r \\right]P=[​x​​​y​​​z​​] 也可以将向量写成三行一列的形式： P=[xyz]P =\r \\left[ \r \\begin{array}{cc} \r x \\\\\r y \\\\\r z \\\\ \r \\end{array} \r \\right]P=​⎣​⎢​⎢​⎡​​​x​y​z​​​​⎦​⎥​⎥​⎤​​ 这两种不同的模式只是一个习惯。 当是一行三列的时候： [xyz]∗[C00C01C02C10C11C12C20C21C22]=[x′y′z′]\r \\left[ \r \\begin{array}{cc} \r x & y & z\r \\end{array} \r \\right] * \\left[ \r \\begin{array}{cc} \r C_{00} & C_{01} & C_{02} \\\\\r C_{10} & C_{11} & C_{12} \\\\\r C_{20} & C_{21} & C_{22} \\\\\r \\end{array} \r \\right] = \\left[ \r \\begin{array}{cc} \r x' & y' & z'\r \\end{array} \r \\right] [​x​​​y​​​z​​]∗​⎣​⎢​⎢​⎡​​​C​00​​​C​10​​​C​20​​​​​​C​01​​​C​11​​​C​21​​​​​C​02​​​C​12​​​C​22​​​​​⎦​⎥​⎥​⎤​​=[​x​′​​​​​y​′​​​​​z​′​​​​] 当是三行一列的时候： [C00C01C02C10C11C12C20C21C22]∗[xyz]=[x′y′z′]\r \\left[ \r \\begin{array}{cc} \r C_{00} & C_{01} & C_{02} \\\\\r C_{10} & C_{11} & C_{12} \\\\\r C_{20} & C_{21} & C_{22} \\\\\r \\end{array} \r \\right] * \\left[ \r \\begin{array}{cc} \r x \\\\ y \\\\ z\r \\end{array} \r \\right] = \\left[ \r \\begin{array}{cc} \r x' \\\\ y' \\\\ z'\r \\end{array} \r \\right] ​⎣​⎢​⎢​⎡​​​C​00​​​C​10​​​C​20​​​​​​C​01​​​C​11​​​C​21​​​​​C​02​​​C​12​​​C​22​​​​​⎦​⎥​⎥​⎤​​∗​⎣​⎡​​​x​y​z​​​⎦​⎤​​=​⎣​⎡​​​x​′​​​y​′​​​z​′​​​​​⎦​⎤​​ 变换的结合顺序 若想对点P先使用变换矩阵T，然后绕Z轴旋转矩阵Rz，然后绕Y轴旋转矩阵Ry，得到点P'。 使用一行三列的时候： P′=P∗T∗Rz∗RyP' = P * T * Rz * RyP​′​​=P∗T∗Rz∗Ry 使用三行一列的时候： P′=Ry∗Rz∗T∗PP' = Ry * Rz * T * PP​′​​=Ry∗Rz∗T∗P 因为矩阵的乘法符合结合律。 一般情况下是列向量。 Copyright whpointz 2017 all right reserved，powered by GitbookThe revision time: 2017-10-27 23:49:43 "},"SourceCode/Geometry.html":{"url":"SourceCode/Geometry.html","title":" Geometry ","keywords":"","body":"通用矢量类的实现 template class Vec3 { public: Vec3() : x(0), y(0), z(0) {} Vec3(T xx) : x(xx), y(xx), z(xx) {} Vec3(T xx, T yy, T zz) : x(xx), y(yy), z(zz) {} Vec3 operator + (const Vec3 &v) const { return Vec3(x + v.x, y + v.y, z + v.z); } Vec3 operator - (const Vec3 &v) const { return Vec3(x - v.x, y - v.y, z - v.z); } Vec3 operator * (const T &r) const { return Vec3(x * r, y * r, z * r); } T dotProduct(const Vec3 &v) const { return x * v.x + y * v.y + z * v.z; } T crossProduct(const Vec3 &v) const { return Vec3(y * v.z - z * v.y, z * v.x - x * v.z, x * v.y - y * v.x); } T norm() const { return x * x + y * y + z * z; } T length() const { return sqrt(norm()); } const T& operator [] (uint8_t i) const { return (&x)[i]; } T& operator [] (uint8_t i) { return (&x)[i]; } Vec3& normalize() { T n = norm(); if (n > 0) { T factor = 1 / sqrt(n); x *= factor, y *= factor, z *= factor; } return *this; } friend std::ostream& operator &v) { return s Vec3f; typedef Vec3 Vec3i; Copyright whpointz 2017 all right reserved，powered by GitbookThe revision time: 2017-10-27 23:52:10 "}}